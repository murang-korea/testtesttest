<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>랜덤 미로 게임</title>
<style>
  :root{--bg:#0f1720;--panel:#0b1220;--accent:#ffd166;--text:#e6eef8}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,'Noto Sans',sans-serif;display:flex;align-items:center;justify-content:center;padding:12px}
  .wrap{width:100%;max-width:720px}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:8px}
  h1{font-size:18px;margin:0}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button,select{padding:8px 10px;border-radius:8px;border:0;background:var(--panel);color:var(--text);cursor:pointer}
  #hud{display:flex;gap:12px;align-items:center;margin:8px 0;font-weight:700}
  canvas{display:block;width:100%;height:auto;background:#071023;border-radius:10px;touch-action:none}
  .footer{display:flex;gap:8px;justify-content:center;margin-top:8px;flex-wrap:wrap}
  .dirBtn{width:56px;height:56px;border-radius:10px;background:#0b1220;border:0;color:var(--text);font-weight:700}
  .note{font-size:12px;color:#9fb0c8;text-align:center;margin-top:6px}
  @media(max-width:420px){ .dirBtn{width:48px;height:48px} }
</style>
</head>
<body>
<div class="wrap" role="application" aria-label="랜덤 미로 게임">
  <header>
    <h1>랜덤 미로</h1>
    <div class="controls">
      <label for="size">크기</label>
      <select id="size">
        <option value="10">작음(10×10)</option>
        <option value="20" selected>중간(20×20)</option>
        <option value="30">큼(30×30)</option>
      </select>
      <button id="newBtn">새 미로</button>
      <button id="solveBtn">해답 보기</button>
    </div>
  </header>

  <div id="hud">
    <div>시간: <span id="time">00:00</span></div>
    <div>이동: <span id="moves">0</span></div>
    <div>최고 시간: <span id="best">-</span></div>
  </div>

  <canvas id="c" width="600" height="600" role="img" aria-label="미로"></canvas>

  <div class="footer" aria-hidden="false">
    <button id="up" class="dirBtn">▲</button>
    <div style="display:flex;gap:8px">
      <button id="left" class="dirBtn">◀</button>
      <button id="down" class="dirBtn">▼</button>
      <button id="right" class="dirBtn">▶</button>
    </div>
  </div>

  <div class="note">화면을 스와이프하거나 버튼/화살표 키로 이동하세요. 도착하면 자동으로 결과가 표시됩니다.</div>
</div>

<script>
(() => {
  // ==== 설정 ====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  const timeEl = document.getElementById('time');
  const movesEl = document.getElementById('moves');
  const bestEl = document.getElementById('best');
  const newBtn = document.getElementById('newBtn');
  const solveBtn = document.getElementById('solveBtn');
  const sizeSel = document.getElementById('size');
  const upBtn = document.getElementById('up'), downBtn = document.getElementById('down'), leftBtn = document.getElementById('left'), rightBtn = document.getElementById('right');

  // state
  let cols = parseInt(sizeSel.value), rows = cols;
  let cellSize = 20;
  let grid = []; // each cell: walls bitmask N=1,E=2,S=4,W=8, visited flag separate
  let visited = [];
  let stack = [];
  let player = {cx:0, cy:0}; // cell coordinates
  let goal = {cx: cols-1, cy: rows-1};
  let moves = 0;
  let timer = null, startTs = 0, elapsed = 0, running = false;
  let bestKey = 'maze_best_' + cols + 'x' + rows;
  let solving = false, solvePath = [];
  let swipeStart = null;

  // Directions convenience
  const DIRS = [
    {dx:0,dy:-1, bit:1, opp:4}, // N
    {dx:1,dy:0,  bit:2, opp:8}, // E
    {dx:0,dy:1,  bit:4, opp:1}, // S
    {dx:-1,dy:0, bit:8, opp:2}  // W
  ];

  // Responsive canvas fit
  function fitCanvas(){
    const maxW = Math.min(window.innerWidth - 28, 720);
    canvas.style.width = maxW + 'px';
    canvas.style.height = (maxW) + 'px';
    // internal resolution fixed for crispness:
    canvas.width = 600; canvas.height = 600;
    draw();
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // ==== 미로 생성: recursive backtracker ====
  function initGrid(c, r){
    cols = c; rows = r;
    grid = new Array(cols*rows).fill(0);
    visited = new Array(cols*rows).fill(false);
    stack = [];
    player = {cx:0, cy:0};
    goal = {cx: cols-1, cy: rows-1};
    moves = 0;
    updateHUD();
    solving = false; solvePath = [];
  }

  function idx(x,y){ return y*cols + x; }

  function neighbors(x,y){
    const list = [];
    for(const d of DIRS){
      const nx = x + d.dx, ny = y + d.dy;
      if(nx>=0 && nx<cols && ny>=0 && ny<rows && !visited[idx(nx,ny)]){
        list.push({x:nx,y:ny,dir:d});
      }
    }
    return list;
  }

  function carveMaze(){
    // start at 0,0
    visited.fill(false);
    grid.fill(0);
    const sx = 0, sy = 0;
    visited[idx(sx,sy)]=true;
    stack = [{x:sx,y:sy}];
    while(stack.length){
      const cur = stack[stack.length-1];
      const nbors = neighbors(cur.x,cur.y);
      if(nbors.length===0){
        stack.pop();
      } else {
        const choice = nbors[Math.floor(Math.random()*nbors.length)];
        // remove wall between cur and choice
        const cx = cur.x, cy = cur.y;
        const nx = choice.x, ny = choice.y;
        // find dir
        for(const d of DIRS){
          if(cx + d.dx === nx && cy + d.dy === ny){
            grid[idx(cx,cy)] |= d.bit;
            grid[idx(nx,ny)] |= d.opp;
            break;
          }
        }
        visited[idx(nx,ny)] = true;
        stack.push({x:nx,y:ny});
      }
    }
  }

  // ==== Drawing ====
  function draw(){
    const W = canvas.width, H = canvas.height;
    ctx.fillStyle = '#071023'; ctx.fillRect(0,0,W,H);

    // compute cell size based on cols/rows
    cellSize = Math.min(W/cols, H/rows);
    const marginX = (W - cellSize*cols)/2;
    const marginY = (H - cellSize*rows)/2;

    // background
    ctx.fillStyle = '#0b1722';
    ctx.fillRect(marginX, marginY, cellSize*cols, cellSize*rows);

    // walls
    ctx.strokeStyle = '#dbeafe';
    ctx.lineWidth = Math.max(1, cellSize*0.06);
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const cell = grid[idx(x,y)];
        const px = marginX + x*cellSize, py = marginY + y*cellSize;
        // North
        if(!(cell & 1)){
          ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px+cellSize,py); ctx.stroke();
        }
        // East
        if(!(cell & 2)){
          ctx.beginPath(); ctx.moveTo(px+cellSize,py); ctx.lineTo(px+cellSize,py+cellSize); ctx.stroke();
        }
        // South
        if(!(cell & 4)){
          ctx.beginPath(); ctx.moveTo(px,py+cellSize); ctx.lineTo(px+cellSize,py+cellSize); ctx.stroke();
        }
        // West
        if(!(cell & 8)){
          ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px,py+cellSize); ctx.stroke();
        }
      }
    }

    // highlight start and goal
    const drawCell = (cx,cy,fill)=> {
      const px = marginX + cx*cellSize, py = marginY + cy*cellSize;
      ctx.fillStyle = fill;
      ctx.fillRect(px + cellSize*0.08, py + cellSize*0.08, cellSize*0.84, cellSize*0.84);
    };
    drawCell(0,0,'#084e74'); // start
    drawCell(goal.cx, goal.cy, '#1b7a2f'); // goal

    // if solving, draw path
    if(solving && solvePath.length){
      ctx.strokeStyle = 'rgba(255, 209, 102, 0.9)';
      ctx.lineWidth = Math.max(2, cellSize*0.08);
      ctx.beginPath();
      for(let i=0;i<solvePath.length;i++){
        const p = solvePath[i];
        const cx = marginX + (p.x + 0.5)*cellSize;
        const cy = marginY + (p.y + 0.5)*cellSize;
        if(i===0) ctx.moveTo(cx,cy); else ctx.lineTo(cx,cy);
      }
      ctx.stroke();
    }

    // player
    const px = marginX + (player.cx + 0.5)*cellSize;
    const py = marginY + (player.cy + 0.5)*cellSize;
    ctx.beginPath();
    ctx.fillStyle = '#ffcf66';
    ctx.arc(px, py, cellSize*0.28, 0, Math.PI*2);
    ctx.fill();
    // face dot
    ctx.fillStyle = '#08233a';
    ctx.beginPath();
    ctx.arc(px, py, Math.max(1, cellSize*0.07), 0, Math.PI*2);
    ctx.fill();
  }

  // ==== Movement ====
  function canMoveTo(cx,cy,dirIndex){
    if(cx<0||cx>=cols||cy<0||cy>=rows) return false;
    const cell = grid[idx(cx,cy)];
    const d = DIRS[dirIndex];
    return !!(cell & d.bit);
  }

  function tryMove(dirIndex){
    if(solving) return; // block input while showing solution
    const d = DIRS[dirIndex];
    const curCell = grid[idx(player.cx, player.cy)];
    if(!(curCell & d.bit)) return; // wall present
    player.cx += d.dx; player.cy += d.dy;
    moves++;
    updateHUD();
    draw();
    checkGoal();
  }

  function checkGoal(){
    if(player.cx === goal.cx && player.cy === goal.cy){
      // stop timer and show result
      stopTimer();
      setTimeout(()=> {
        alert(`완료! 시간: ${formatTime(elapsed)}\n이동수: ${moves}`);
        // save best (by time)
        const key = 'maze_best_time_' + cols + 'x' + rows;
        const prev = Number(localStorage.getItem(key) || 0);
        if(prev === 0 || elapsed < prev){
          localStorage.setItem(key, Math.floor(elapsed));
        }
        updateBest();
      }, 80);
    }
  }

  // ==== Timer / HUD ====
  function startTimer(){
    if(running) return;
    running = true;
    startTs = performance.now() - elapsed;
    tick();
  }
  function tick(ts){
    if(!running) return;
    elapsed = performance.now() - startTs;
    timeEl.textContent = formatTime(elapsed);
    requestAnimationFrame(tick);
  }
  function stopTimer(){
    running = false;
  }
  function resetTimer(){
    stopTimer();
    elapsed = 0;
    timeEl.textContent = formatTime(0);
  }
  function updateHUD(){
    movesEl.textContent = moves;
    timeEl.textContent = formatTime(elapsed);
    updateBest();
  }
  function updateBest(){
    const key = 'maze_best_time_' + cols + 'x' + rows;
    const val = Number(localStorage.getItem(key) || 0);
    bestEl.textContent = val ? formatTime(val) : '-';
  }
  function formatTime(ms){
    const s = Math.floor(ms/1000);
    const mm = Math.floor(s/60).toString().padStart(2,'0');
    const ss = (s%60).toString().padStart(2,'0');
    return `${mm}:${ss}`;
  }

  // ==== Solver (BFS shortest path) ====
  function solveMaze(){
    solving = true;
    // BFS from player to goal
    const q = [];
    const prev = new Array(cols*rows).fill(-1);
    const start = idx(player.cx, player.cy);
    q.push(start);
    const seen = new Array(cols*rows).fill(false);
    seen[start] = true;
    let found = false;
    while(q.length){
      const cur = q.shift();
      const cx = cur % cols, cy = Math.floor(cur / cols);
      if(cx === goal.cx && cy === goal.cy){ found = true; break; }
      const cell = grid[cur];
      for(let di=0; di<DIRS.length; di++){
        const d = DIRS[di];
        if(!(cell & d.bit)) continue;
        const nx = cx + d.dx, ny = cy + d.dy;
        const idn = idx(nx,ny);
        if(!seen[idn]){
          seen[idn] = true;
          prev[idn] = cur;
          q.push(idn);
        }
      }
    }
    if(!found){ solving = false; alert('경로 없음'); return; }
    // reconstruct
    const path = [];
    let curId = idx(goal.cx, goal.cy);
    while(curId !== -1 && curId !== start){
      path.push({x: curId % cols, y: Math.floor(curId/cols)});
      curId = prev[curId];
    }
    path.push({x: player.cx, y: player.cy});
    path.reverse();
    solvePath = path;
    // animate path with short interval
    let i = 0;
    const anim = setInterval(()=>{
      if(i >= path.length){ clearInterval(anim); solving = false; draw(); return; }
      player.cx = path[i].x; player.cy = path[i].y;
      i++;
      draw();
    }, Math.max(30, 500 / Math.sqrt(cols*rows)));
  }

  // ==== Input: keyboard, buttons, swipe ====
  document.addEventListener('keydown', (e)=>{
    if(e.key === 'ArrowUp') { startTimer(); tryMove(0); }
    else if(e.key === 'ArrowRight') { startTimer(); tryMove(1); }
    else if(e.key === 'ArrowDown') { startTimer(); tryMove(2); }
    else if(e.key === 'ArrowLeft') { startTimer(); tryMove(3); }
  });

  upBtn.addEventListener('click', ()=>{ startTimer(); tryMove(0); });
  rightBtn.addEventListener('click', ()=>{ startTimer(); tryMove(1); });
  downBtn.addEventListener('click', ()=>{ startTimer(); tryMove(2); });
  leftBtn.addEventListener('click', ()=>{ startTimer(); tryMove(3); });

  // simple swipe detection
  canvas.addEventListener('touchstart', (e)=>{
    const t = e.touches[0]; swipeStart = {x: t.clientX, y: t.clientY, t: performance.now() };
  }, {passive:true});
  canvas.addEventListener('touchend', (e)=>{
    if(!swipeStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - swipeStart.x, dy = t.clientY - swipeStart.y;
    const dt = performance.now() - swipeStart.t;
    swipeStart = null;
    if(Math.hypot(dx,dy) < 20) return; // tap ignore
    // prioritize dominant axis
    if(Math.abs(dx) > Math.abs(dy)){
      if(dx > 0){ startTimer(); tryMove(1); } else { startTimer(); tryMove(3); }
    } else {
      if(dy > 0){ startTimer(); tryMove(2); } else { startTimer(); tryMove(0); }
    }
  }, {passive:true});

  // also support click/tap on canvas for directional relative movement
  canvas.addEventListener('click', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
    // determine which quadrant relative to player cell center
    const W = canvas.width, H = canvas.height;
    cellSize = Math.min(W/cols, H/rows);
    const marginX = (W - cellSize*cols)/2;
    const marginY = (H - cellSize*rows)/2;
    const px = marginX + (player.cx + 0.5)*cellSize;
    const py = marginY + (player.cy + 0.5)*cellSize;
    const dx = cx - px, dy = cy - py;
    if(Math.abs(dx) > Math.abs(dy)){
      if(dx > 0) { startTimer(); tryMove(1); } else { startTimer(); tryMove(3); }
    } else {
      if(dy > 0) { startTimer(); tryMove(2); } else { startTimer(); tryMove(0); }
    }
  });

  // ==== Controls: New maze / size / solve ====
  newBtn.addEventListener('click', ()=>{
    cols = parseInt(sizeSel.value); rows = cols;
    initGrid(cols, rows);
    carveMaze();
    resetTimer();
    updateHUD();
    draw();
    bestKey = 'maze_best_time_' + cols + 'x' + rows;
  });
  solveBtn.addEventListener('click', ()=>{
    if(!solving) solveMaze();
  });

  sizeSel.addEventListener('change', ()=>{
    // update best key preview
    const newCols = parseInt(sizeSel.value);
    const key = 'maze_best_time_' + newCols + 'x' + newCols;
    const val = Number(localStorage.getItem(key) || 0);
    bestEl.textContent = val ? formatTime(val) : '-';
  });

  // ==== Initialization ====
  function startNew(){
    cols = parseInt(sizeSel.value); rows = cols;
    initGrid(cols, rows);
    carveMaze();
    resetTimer();
    moves = 0;
    running = false;
    elapsed = 0;
    updateHUD();
    draw();
    updateBest();
  }

  // initial boot
  startNew();
  fitCanvas();

  // expose for debug if needed
  window._maze = { grid, cols, rows, player };
})();
</script>
</body>
</html>